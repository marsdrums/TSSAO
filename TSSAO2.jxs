<jittershader name="default">
	<description>Default Slab </description>
	<param name="buffer_col" 		type="int" 		default="0" />
	<param name="buffer_norm" 		type="int" 		default="1" />
	<param name="buffer_pos" 		type="int" 		default="2" />
	<param name="buffer_vel"    	type="int"    	default="3" />
	<param name="history" 			type="int" 		default="4" />
	<param name="buffer_rand"   	type="int"  	default="5" />
	<texture file="random-tex.png" 	type="float16" 	unit="5" rectangle="0" filter="none none" wrap="repeat repeat"/>
	<param name="frame" 			type="float" 	default="0." />
	<param name="MVP" 				type="mat4" 	state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="P" 				type="mat4" 	state="CAM_PROJECTION_MATRIX" />
	<param name="invP" 				type="mat4" 	state="PROJECTION_MATRIX" transform="INVERSE" />
	<param name="uv"   				type="vec2"   	state="TEXCOORD" />
	<param name="textureMatrix0" 	type="mat4" 	state="TEXTURE0_MATRIX" />
	<param name="pos" 				type="vec3" 	state="POSITION" />
	<param name="farClip" 			type="float" 	state="FAR_CLIP" />
	<param name="farCorner" 		type="vec3" 	state="FAR_CORNER" />	
	<language name="glsl" version="1.5">
		<bind param="buffer_col" 			program="fp" />
		<bind param="buffer_norm" 		program="fp" />
		<bind param="buffer_pos"  		program="fp" />
		<bind param="buffer_vel"   		program="fp" />
		<bind param="history"   		program="fp" />
		<bind param="buffer_rand"  		program="fp" />
		<bind param="frame" 			program="fp" />
		<bind param="MVP" 				program="vp" />
		<bind param="P"   				program="fp" />
		<bind param="invP"   			program="fp" />
		<bind param="uv"   				program="vp" />
		<bind param="textureMatrix0" 	program="vp" />
		<bind param="textureMatrix0" 	program="fp" />
		<bind param="pos" 				program="vp" />
		<bind param="farCorner"  		program="vp" />
		<bind param="farClip"   		program="fp" />
<program name="vp" type="vertex"  >
<![CDATA[
#version 330 core

in vec3 pos;
in vec2 uv;

uniform mat4 MVP;
uniform mat4 textureMatrix0;
uniform vec3 farCorner;


out jit_PerVertex {
	smooth vec2 testUV;
	smooth vec2 uv;
	smooth vec3 rd;
} jit_out;

void main(void) {
	gl_Position = MVP*vec4(pos, 1.);
	//vec2 uv = 0.5 * (gl_Position.xy + vec2(1.));
	jit_out.uv = vec2(textureMatrix0*vec4(uv, 1., 1.)).xy;
	jit_out.rd = farCorner * vec3(gl_Position.xy, 1);
	jit_out.testUV = uv;
}
]]>
</program>

<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core
#define TWOPI 6.28318531
#define PI 3.14159265

uniform mat4 			P, invP, textureMatrix0;
uniform sampler2DRect 	buffer_col, buffer_norm, buffer_pos, buffer_vel, history;
uniform sampler2D  		buffer_rand;
uniform float 			farClip;
uniform float 			frame;

in jit_PerVertex {
	smooth vec2 testUV;
	smooth vec2 uv;
	smooth vec3 rd;
} jit_in;

layout (location = 0) out vec4 col;
layout (location = 1) out vec4 oldOcc;

//sampler g_buffer_norm; 
//sampler g_buffer_pos; 
//sampler g_random; 
const float random_size		= 1.; 
const float g_sample_rad	= 3.; 
const float g_intensity		= 2.; 
const float g_scale			= 1.; 
const float g_bias			= 0.001; 

//struct PS_INPUT { float2 uv : TEXCOORD0; }; 
//struct PS_OUTPUT { float4 color : COLOR0; }; 
vec3 hash( uvec3 x )
{
    x = ((x>>8U)^x.yzx)*1103515245U;
    x = ((x>>8U)^x.yzx)*1103515245U;
    x = ((x>>8U)^x.yzx)*1103515245U;
    
    return vec3(x)*(1.0/float(0xffffffffU));
}
vec3 	getPosition(in vec2 uv){
	return texture(buffer_pos,uv).xyz;
}
vec3 	getNormal(in vec2 uv){
	return normalize(texture(buffer_norm, uv).xyz);
}
vec2 	getRandom(in vec2 uv){
	return normalize(texture(buffer_rand, uv ).xy * 2.0f - 1.0f); 
}
float 	getAmbientOcclusion(in vec2 tcoord,in vec2 uv, in vec3 p, in vec3 cnorm){

				uv 		= 	(textureMatrix0*vec4(uv, 1., 1.)).xy;
		vec3 	diff 	= 	getPosition(tcoord + uv) - p; 
   		vec3 	v 		= 	normalize(diff); 
   		float 	d 		= 	length(diff)*g_scale; 
  		return 				max(0.0,dot(cnorm,v)-g_bias)*(1.0/(1.0+d))*g_intensity;
}

void main(void) {

  	const 	vec2 	vec[4] 	= 	vec2[] (	vec2(+1,+0),
  											vec2(-1,+0), 
  											vec2(+0,+1),
  											vec2(+0,-1)
  										);

  	vec3 	p 		= 	getPosition(jit_in.uv); 
  	vec3 	n 		= 	getNormal(jit_in.uv); 
    vec2 	vel 		= 	texture(buffer_vel, jit_in.uv).rg;
    vec2 	histUV 		= 	jit_in.testUV - vel;
  	vec3 	aoHistory 	= 	texture(history, (textureMatrix0*vec4(histUV, 1., 1.)).xy).xyz; //occ, iterCount, prevDepth
  	float  	aoPrev 	= 	aoHistory.x;
  	float   iterCount 	= 	clamp(aoHistory.y, 0., 1.);
  	float   prevDepth 	= 	aoHistory.z;

  	int iterations = 1;

  	//disocclusion?
    if(histUV.x < 0. || histUV.x >= 1. || histUV.y < 0. || histUV.y >= 1. || abs(1. - (p.z / prevDepth)) > 0.1)
    {
    		iterCount 	= 0.;
    		iterations  = 2;
    }

  	//**SSAO Calculation**//
  	float 	ao 		= 	0.0; 
  	int aoSamples = 4;

  	for (int j = 0; j < iterations; j++){
  		vec2 	rand 	= 	getRandom(vec2(mod(jit_in.testUV.x + float(j)*0.1, 1.), jit_in.testUV.y));  
    	float   randRad = 	hash(uvec3(jit_in.uv, frame+j*10.)).x;
  		float 	rad 	= 	g_sample_rad*randRad/p.z; 

	  	for (int i = 0; i < aoSamples; i++){
	  		vec2 	coord1 = reflect(vec[i],rand)*rad; 
	  		vec2 	coord1_07 = coord1*0.707;
	    	vec2 	coord2 = vec2(coord1_07.x - coord1_07.y, coord1_07.x + coord1_07.y); 
	    
	    			ao += getAmbientOcclusion(jit_in.uv,coord1*0.25, p, n); 
	    			ao += getAmbientOcclusion(jit_in.uv,coord2*0.5, 	p, n); 
	    			ao += getAmbientOcclusion(jit_in.uv,coord1*0.75, p, n); 
	    			ao += getAmbientOcclusion(jit_in.uv,coord2, 		p, n); 
	  	}
  	}
	  		ao 	/=	float(aoSamples)*float(iterations)*4.; 

	  		float  	blend 		=	clamp(iterCount*100., 0., 0.95);//1. / (iterCount*100. + 1.);
	  		ao 			= 	mix(ao, aoPrev, blend);
	  		iterCount 	+= 	0.01;
	  		prevDepth 	= 	p.z;
	  		oldOcc 		= 	vec4(ao, iterCount, prevDepth, 1.);
	   		
	   		col.rgb = vec3(1. - ao);
	   		col.a = 1.;
}

]]>
</program>
	</language>
</jittershader>
